Executive Summary

Scope & Purpose:

Project # 3 was implementation of 2 phase commit. The purpose was to understand how this protocol works and how it can be implemented even at a smaller level with all the characteristics of 2 phase commit. Understanding how consistency, communication and liveness is managed and what are the resulting pros and cons of using two phase commit at a bigger level with many nodes and multiple on-going processes. 

Technical Impression:

This project encompassing the implementation of 2 phase commit was relatively more complicated to implement as compared to the previous two projects. We chose Python and it made the implementation much shorter and simpler. 

In our project the client code is the same as we had before in project 2. We have used RPC for the communication between the Client and any Server from the set of 5 servers. Each server can read through a file that has information about other servers like their IP address and port numbers. Whenever the client connects to any server and sends a command, that server becomes the coordinator and connects to all other servers through TCP sockets. Then it performs the two phase commit by first sending the information, waiting for acknowledgements, then sending the ‘go’ message and getting back the acknowledgments. Once its done, the coordinator server sends back the response to the client. This way the client can connect to any server and each server has two threads for communication, one to communicate with clients and one for other servers.

The testing for this project was a bit more tedious as we had to initialize 5 servers and a client and copy our code to each one of them. We used a script to replicate our code on each server anytime we make any changes. Overall it was technically a great experience to implement the protocol and analyze it in real time. 
